There are multiple ways to configure bean life cycles methods in your spring application as described below.
1.Using spring core annotations (@PostConstruct and @PreDestroy)
2.Using spring XML configuration(init-method and destroy-method)
3.Implementing interfaces like Iinitializingbean and disposablebean

@controller and @RestController
===============================
When you use the @ResponseBody annotation on a method, Spring converts the return value and writes it to the HTTP response automatically. 
Each method in the Controller class must be annotated with @ResponseBody.

@Controller
@RequestMapping("employees")
public class EmployeeController {
    Employee employee = new Employee();
    @RequestMapping(value = "/{name}", method = RequestMethod.GET, produces = "application/json")
    public @ResponseBody Employee getEmployeeInJSON(@PathVariable String name) {
       employee.setName(name);
       employee.setEmail("employee1@genuitec.com");
    return employee; 
    }
	
Spring 4.0 introduced @RestController, a specialized version of the controller which is a convenience annotation that does nothing
 more than add the @Controller and @ResponseBody annotations. By annotating the controller class with @RestController annotation, 
 you no longer need to add @ResponseBody to all the request mapping methods. The @ResponseBody annotation is active by default.

@RestController
@RequestMapping("employees")
public class EmployeeController {
    Employee employee = new Employee();
    @RequestMapping(value = "/{name}", method = RequestMethod.GET, produces = "application/json")
    public Employee getEmployeeInJSON(@PathVariable String name) {
       employee.setName(name);
       employee.setEmail("employee1@genuitec.com");
       return employee;
    }

Scopes in Spring
================
singleton – only one instance of the spring bean will be created for the spring container. This is the default spring bean scope. 
			While using this scope, make sure bean doesn’t have shared instance variables otherwise it might lead to data inconsistency issues.
prototype – A new instance will be created every time the bean is requested from the spring container.
request – This is same as prototype scope, however it’s meant to be used for web applications. 
			A new instance of the bean will be created for each HTTP request.
session – A new bean will be created for each HTTP session by the container.
global-session – This is used to create global session beans for Portlet applications.
			

difference in container
======================
BeanFactory is also called basic IOC and ApplicationContext is called Advanced IOC. 
Although BeanFactory and ApplicationContext both are used to get the beans from IOC container by using method getBean(String beanName).

BeanFactory uses lazy initialization approach whereas ApplicationContext uses eager initialization approach.
i.e BeanFactory creates a singleton bean only when it is requested from it but ApplicationContext creates all singleton beans at the time of its own initialization.

ApplicationContext creates and manages resources objects on its own whereas BeanFactory used to be explicitly 
1.	Resource resource=new ClassPathResource("applicationContext.xml");  
2.	BeanFactory factory=new XmlBeanFactory(resource);

1.	ApplicationContext context =  new ClassPathXmlApplicationContext("applicationContext.xml");  

 Annotation based dependency Injection is not supported by BeanFactory whereas ApplicationContext supports using annotation @PreDestroy, @Autowired.
 

Annotation in Spring
=================== 
@Controller
@RequestMapping(value = "/bookcase")
public class BookCaseController {
 
    private BookCase bookCase;
 
    @RequestMapping(method = RequestMethod.GET)
    @ResponseBody
    public BookCase getBookCase() {
        return this.bookCase;
		
@ResponseBody
===============
This annotation indicates a method return value should be bound to the web response body. 
To put this in simple words, @ResponseBody tell Spring framework to serialize return object into JSON or XML 
and send this information back as part of the HTTPResponse.
With Spring 4.x, If we are using working on the REST API, we should not use @ResponseBody on method level, 
but rather <@RestController on class level.@RestController is a composed annotation that is 
itself meta-annotated with @Controller and @ResponseBody.

@RequestBody
This annotation indicating a method parameter should be bound to the body of the web request. 
To put it in layman terms, the @RequestBody annotation binds the HTTPRequest body to the domain object. 
Spring framework automatically deserializes incoming HTTPRequest to the Java object using Http Message Converters .



@RequestMapping 
================
is one of the most common annotation used in Spring Web applications. 
This annotation maps HTTP requests to handler methods of MVC and REST controllers.

The @RequestMapping annotation can be applied to class-level and/or method-level in a controller.
The class-level annotation maps a specific request path or pattern onto a controller. 
You can then apply additional method-level annotations to make mappings more specific to handler methods.
@RequestMapping("/home")
public class IndexController {
  @RequestMapping("/")
  String get(){
    //mapped to hostname:port/home/
    return "Hello from get";
  }
  @RequestMapping("/index")
  String index(){
    //mapped to hostname:port/home/index/
    return "Hello from index";
  }
		

auto wiring with example
=======================
1)  no	    It is the default autowiring mode. It means no autowiring bydefault.
2)	byName	The byName mode injects the object dependency according to name of the bean. In such case, property name and bean name must be same. It internally calls setter method.
3)	byType	The byType mode injects the object dependency according to type. So property name and bean name can be different. It internally calls setter method.
4)	constructor	The constructor mode injects the dependency by calling the constructor of the class. It calls the constructor having large number of parameters.


what are handler mapping
==========================
<servlet>    
    <servlet-name>spring</servlet-name>    
    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>    
    <load-on-startup>1</load-on-startup>      
</servlet>  

In Spring MVC, the DispatcherServlet acts as front controller – receiving all incoming HTTP requests and processing them.

Simply put, the processing occurs by passing the requests to the relevant component with the help of handler mappings.

HandlerMapping is an interface that defines a mapping between requests and handler objects. While Spring MVC framework provides some ready-made implementations, the interface can be implemented by developers to provide customized mapping strategy.

This article discusses some of the implementations provided by Spring MVC namely BeanNameUrlHandlerMapping, SimpleUrlHandlerMapping, ControllerClassNameHandlerMapping, their configuration, and the differences between them.

BeanNameUrlHandlerMapping
BeanNameUrlHandlerMapping is the default HandlerMapping implementation. BeanNameUrlHandlerMapping maps request URLs to beans with the same name.

SimpleUrlHandlerMapping
Next, the SimpleUrlHandlerMapping is the most flexible HandlerMapping implementation. It allows for direct and declarative mapping between either bean instances and URLs or between bean names and URLs.

ControllerClassNameHandlerMapping (removed in Spring 5)
The ControllerClassNameHandlerMapping maps URL to a registered controller bean (or a controller annotated with the @Controller annotation) that has, or starts with, the same name.

It can be more convenient in many scenarios especially for simple controller implementations that handle a single request type. The convention used by Spring MVC is to use the name of the class and remove the “Controller” suffix, then change the name to a lower case and return it as the mapping with a leading “/”.

For example “WelcomeController” would return as mapping to “/welcome*”, i.e. to any URL that starts with “welcome”.